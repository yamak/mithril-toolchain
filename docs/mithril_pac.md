# Mithril PAC Specification
**Target:** RISC-V 32-bit (Ibex Core)

---

## 1. Architectural Overview

Mithril is a hardware-accelerated Control-Flow Integrity (CFI) architecture for embedded RISC-V processors. It mitigates Return-Oriented Programming (ROP) and Jump-Oriented Programming (JOP) attacks using cryptographic Pointer Authentication (PAC) with near-zero runtime overhead.

**Key principles:**

- **Zero-Cycle Overhead:** PAC generation and verification are hidden inside natural pipeline bubbles (fetch latency, branch penalty) and do not introduce additional stalls in the common case.
- **Dedicated PAC State:** PAC values are stored in dedicated hardware registers (`pr0`, `pr1`) to avoid general-purpose register (GPR) pollution.
- **Ephemeral Keys:** A 128-bit secret key is generated by an on-chip TRNG at every boot, invalidating all previous PAC values after reset.
- **OS Control:** Automatic PAC enforcement can be enabled or disabled by the bootloader or operating system via control CSRs.

---

## 2. Programming Model and ISA

### 2.1. Mithril PAC Registers (Banked PAC State)

PAC registers are not part of the GPR file and cannot be accessed by standard arithmetic or load/store instructions. They are read and written only by Mithril PAC logic and PAC-specific instructions.

| PAC Register | Width  | Access | Description |
|-------------|--------|--------|-------------|
| **`pr0`** | 64-bit | R/W via Mithril logic only | Return-PAC domain for normal function returns and optional data-pointer authentication. |
| **`pr1`** | 64-bit | R/W via Mithril logic only | IRQ-PAC domain for interrupt and exception returns (`mret`). |

> `pr0` and `pr1` are independent PAC domains and are not shadow copies of each other.

The instruction encoding reserves 5 bits for PAC register specifiers, allowing the register file to be extended up to **32 PAC registers** in future implementations. This scalability enables support for additional security domains, such as multi-level privilege separation or fine-grained forward-edge CFI.

---

### 2.2. Control and Status Registers (CSRs)

| CSR | Address | Description |
|-----|---------|-------------|
| **`mpackey0`–`mpackey3`** | `0x7C0`–`0x7C3` | 128-bit master key, loaded from TRNG during boot. |
| **`mpacctx`** | `0x7C4` | Context identifier managed by the OS (process/thread ID). |
| **`mpacctrl`** | `0x7C5` | PAC control register. Bit 0: `PAC_ENABLE` (sticky latch). |

> **Irreversible Enablement:** The `PAC_ENABLE` bit is implemented as a sticky latch. Once set to 1 by the bootloader, it cannot be cleared by software until the next system reset. This prevents attackers from disabling PAC enforcement at runtime.

---

## 3. Implicit (Automatic) PAC Operations

Implicit operations do not increase code size and are active only when `mpacctrl.PAC_ENABLE == 1`.

### 3.1. Return Address Determination

For call instructions, the next return address (`RA_next`) is determined as:

- Compressed instruction: `RA_next = PC + 2`
- Non-compressed instruction: `RA_next = PC + 4`

This exactly matches the value written to the architectural link register.

### 3.2. Implicit PAC Semantics

| Event | Message | Tweak | PAC Domain | Operation |
|------|---------|-------|------------|-----------|
| **`JAL` / `JALR` (link)** | `{ RA_next, SP }` | `CtxDerived` | `pr0` | `pr0 = Qarma(Key, Msg, Tweak)` |
| **`RET` (`JALR ra`)** | `{ RA, SP }` | `CtxDerived` | `pr0` | `Assert(pr0 == Qarma(Key, Msg, Tweak))` |
| **Trap entry (IRQ/exception)** | `{ MEPC, SP }` | `CtxDerived` | `pr1` | `pr1 = Qarma(Key, Msg, Tweak)` |
| **`MRET`** | `{ MEPC, SP }` | `CtxDerived` | `pr1` | `Assert(pr1 == Qarma(Key, Msg, Tweak))` |

---

## 3.3. PAC Computation Latency

Mithril performs PAC generation and authentication using a **two-cycle cryptographic pipeline** integrated into the processor datapath.

- **Cycle 1:** QARMA Stage 1 (initial whitening and forward rounds)  
- **Cycle 2:** QARMA Stage 2 (backward rounds and final whitening)

Although the cryptographic operation requires **two hardware cycles to complete**, this latency is **fully hidden** by existing pipeline bubbles:

- During function calls (`JAL` / `JALR`), PAC computation overlaps with the **instruction fetch latency** of the callee.
- During returns (`RET`) and exception returns (`MRET`), PAC verification overlaps with **speculative control-flow redirection** and is resolved before architectural state commit.

As a result, Mithril introduces **zero additional stall cycles** in the steady state, while still providing full cryptographic control-flow integrity.

## 3.4. QARMA Round Configuration and Frequency Scaling

Mithril uses a configurable instance of **QARMA-64** as its underlying cryptographic primitive.  
In the current implementation, the design is optimized for **embedded-class operating frequencies**.

- **Default configuration:**  
  - **5 forward rounds + 5 backward rounds + 2 whitening steps**  
  - **Total: 12 rounds**
  - Verified to meet timing closure on a **50 MHz Ibex core** without additional pipeline stages.

This configuration provides a strong security margin while maintaining a compact and timing-safe datapath.

### Frequency Scaling Trade-off

For deployments requiring **higher operating frequencies**, the number of QARMA rounds can be reduced:

- **High-frequency configuration:**  
  - **3 forward rounds + 3 backward rounds + 2 whitening steps**  
  - **Total: 8 rounds**

This reduced-round configuration significantly shortens the critical path and enables higher clock rates, at the cost of a modest reduction in cryptographic strength.

Notably, this trade-off aligns with existing industry practice:  
**ARM Pointer Authentication implementations also deploy reduced-round QARMA configurations (e.g., 3 rounds) in performance-constrained designs.**

As a result, Mithril allows system designers to **explicitly trade security margin for frequency scalability**, while preserving the same architectural PAC semantics and control-flow integrity guarantees.



## 4. Context-Derived Tweak

All PAC computations use a context-derived tweak:

Tweak = (s0 || s1) ⊕ mpacctx


- **Local context (`s0 || s1`):** Concatenation of callee-saved registers `s0` (frame pointer) and `s1`, sampled at PAC generation and verification points from committed architectural state.
- **Global context (`mpacctx`):** Updated by the OS during process or thread switches to prevent cross-context PAC reuse.

---

## 5. Explicit Mithril PAC Instructions

Explicit instructions are used for forward-edge CFI and for saving/restoring PAC state in non-leaf functions.

### 5.1. Operand Conventions

- `prd` / `prs` must be `pr0` or `pr1`.
- GPRs are used only as message operands.
- PAC registers cannot be used as GPR operands.

---

### 5.2. Instruction Definitions

#### `pac.sign`

pac.sign prd, rs1, rs2

prd = Qarma(Key, Msg={rs1, rs2}, Tweak=CtxDerived)


---

#### `pac.auth`

pac.auth prs, rs1, rs2

expected = Qarma(Key, Msg={rs1, rs2}, Tweak=CtxDerived)
Assert(prs == expected)


---

#### `pac.store`

pac.store prs, offset(rs1)
Mem64[rs1 + offset] = prs


---

#### `pac.load`

pac.load prd, offset(rs1)
prd = Mem64[rs1 + offset]


---

## 6. Boot and Key Generation (Root of Trust)

1. Power-on reset activates the TRNG.
2. 128 bits of entropy are collected.
3. Hardware writes the key into `mpackey0–mpackey3` before first instruction execution.
4. Key CSRs are locked against software writes.
5. Reboot regenerates a new key and invalidates old PAC values.

---

## 7. Pipeline Integration (Ibex 2-Stage)

### 7.1. Function Call (`JAL`) — Fetch Hiding

- **T0 (ID/EX):** Call target and `RA_next` are computed. QARMA Stage 1 starts with `{RA_next, SP}`.
- **T1 (IF):** Target instruction fetch occurs while QARMA Stage 2 completes and writes to `pr0`.

No additional stall cycles are introduced.

---

### 7.2. Function Return (`RET`) — Late Fault

- **T0 (ID/EX):** Speculative jump to `RA`. QARMA Stage 1 starts.
- **T1 (IF):** Target instruction is fetched and PAC is verified.
- **T2 (ID/EX):**
  - Mismatch: instruction is squashed and an exception is raised.
  - Match: execution continues normally.

---

### 7.3. Trap Entry and `MRET`

- Trap entry: `pr1 = Qarma(Key, {MEPC, SP}, Tweak)`
- `mret`: PAC is recomputed and verified against `pr1` before returning.

---

### 7.4. Exception Handling

#### 7.4.1. PAC Mismatch Exception

When PAC verification fails during `RET` or `MRET`, a `PAC_MISMATCH` exception is raised. The exception handler can identify this condition by checking the `mcause` register.

#### 7.4.2. Nested Interrupt Safety

Ibex automatically disables interrupts upon trap entry (`mstatus.MIE = 0`). To safely enable nested interrupts while preserving PAC state, the following sequence **MUST** be used:

1. Save `pr1` to stack using `pac.store pr1, offset(sp)`
2. Enable interrupts (`csrsi mstatus, MIE`)
3. Execute handler logic
4. Disable interrupts (`csrci mstatus, MIE`)
5. Restore `pr1` using `pac.load pr1, offset(sp)`
6. Execute `mret`

This ensures that `pr1` is never overwritten before being preserved, allowing arbitrary nesting depth limited only by available stack space.

#### 7.4.3. RTOS Context Switch Protection

This protection is critical in RTOS environments: if an attacker corrupts the saved `MEPC` on the stack during a context switch within an IRQ handler, the PAC verification on `MRET` will detect the tampering and raise an exception, preventing control-flow hijacking.

---

## 8. CFI Coverage Summary

### 8.1. Backward-Edge CFI (Fully Automatic)

- All call/return chains are protected automatically.
- Non-leaf functions save/restore `pr0` using `pac.store` / `pac.load`.
- Leaf functions incur zero additional instructions as long as `SP` is unchanged and `RA` is not spilled.

---

### 8.2. Forward-Edge CFI (Manual / Opt-In)

- Function pointers can be protected using `pac.sign` and `pac.auth`.
- Currently manual; future LLVM backend support is planned.

---

## 9. Toolchain and Software Ecosystem Integration

To ensure that Mithril PAC is not merely a theoretical ISA extension but a **fully usable end-to-end system**, a dedicated software toolchain has been developed and validated.

### 9.1. Dedicated Mithril Toolchain

A complete custom toolchain based on **LLVM + picolibc + GDB** has been created specifically for the Mithril architecture.

- **Compiler:** LLVM/Clang (custom fork)
- **C library:** picolibc
- **Debugger:** GDB (Mithril-aware register definitions)

This toolchain enables PAC-aware compilation, linking, and debugging without requiring manual code instrumentation for the common case.

---

### 9.2. LLVM Backend Extensions

The LLVM backend has been extended with Mithril-specific features:

- A new target feature flag is introduced:

-march=rv32imc_xpac

This flag enables Mithril PAC instructions and exposes the PAC register file (`pr0`, `pr1`) to the backend.

- Automatic backward-edge protection is enabled via:

-mxpac-ret

When this option is set, LLVM automatically inserts:
- `pac.store` instructions in function prologues,
- `pac.load` instructions in function epilogues,
for all **non-leaf functions**.

- **Leaf functions** are automatically detected by the backend:
- Functions that do not modify `SP` and do not spill `RA` are classified as leaf functions.
- No PAC save/restore instructions are emitted for such functions, preserving zero-overhead execution.

As a result, backward-edge CFI is provided **fully automatically**, with no source-level annotations required.

---

### 9.3. Assembly and Runtime Library Support

The picolibc C runtime was audited to ensure full compatibility with Mithril PAC:

- The vast majority of picolibc functions are written in C and are handled automatically by the LLVM backend.
- A **small number of hand-written assembly functions** (non-leaf routines) were identified.
- These assembly routines were manually updated to include:
- `pac.store` in the prologue,
- `pac.load` in the epilogue.

This manual intervention was minimal and limited to a small, well-defined subset of the runtime library.

#### Compiler Runtime (compiler-rt)

In addition to application code and the C runtime library, **LLVM compiler-generated runtime routines** are also built with Mithril PAC enabled.

The **compiler-rt** library is compiled using the same PAC configuration
(e.g., `-march=rv32imc_xpac -mxpac-ret`), ensuring that all non-leaf helper
functions emitted by the compiler participate in the same backward-edge CFI domain.

This prevents gaps in the PAC-protected call/return chain when user code
transitions into compiler runtime routines, preserving end-to-end control-flow
integrity across the entire software stack.

---

### 9.5. Summary

With these toolchain extensions, Mithril provides:

- **Transparent backward-edge protection** for C/C++ code,
- **Zero-overhead leaf functions** without manual annotations,
- A **realistic and deployable workflow** compatible with existing embedded development practices.

This demonstrates that Mithril PAC is not only a secure hardware design, but also a **practical, compiler-integrated CFI solution** suitable for real embedded systems.
